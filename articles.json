[
  {
    "id": 1,
    "title": "Stacks Explained: A Comprehensive Guide",
    "description": "Learn the fundamentals of stacks, a crucial data structure used for managing data in a LIFO (Last In, First Out) manner, along with practical examples in C++ and Python.",
    "category": "Data Structures",
    "publishDate": "2024-09-24",
    "programmingLanguages": ["C++", "Python"],
    "details": {
      "C++": "In C++, a stack can be implemented using the Standard Template Library (STL). The stack is a linear data structure that follows LIFO (Last In First Out) principle. The major operations on a stack are push, pop, and top.",
      "Python": "In Python, the stack can be implemented using lists. Lists in Python provide the functionality of a dynamic array, but they can also be used to implement a stack by using the append() and pop() methods."
    },
    "descriptions": {
      "C++": {
        "constructor": "This is the constructor for the Stack class. It initializes an empty stack with a size of 0 and sets the head to nullptr.",
        "destructor": "This is the destructor for the Stack class. It ensures that all allocated memory is freed when the stack is no longer needed by popping all the elements from the stack.",
        "push": "The push function adds a new element to the top of the stack. It creates a new node and links it as the new head of the stack.",
        "pop": "The pop function removes the top element from the stack. If the stack is empty, it throws an error. Otherwise, it returns the top value and adjusts the head to point to the previous element.",
        "isEmpty": "The isEmpty function checks whether the stack is empty by verifying if the head is nullptr.",
        "main": "This is a sample main function that demonstrates how to use the Stack class by pushing elements onto the stack and then popping them off."
      },
      "Python": {
        "constructor": "This is the constructor for the Stack class in Python. It initializes an empty list that will act as the stack.",
        "push": "The push method appends a new element to the end of the list, representing the top of the stack.",
        "pop": "The pop method removes and returns the last element of the list. It raises an IndexError if the stack is empty.",
        "isEmpty": "The isEmpty method checks whether the stack is empty by verifying if the list has no elements.",
        "main": "This is a sample main function that demonstrates how to use the Stack class in Python by pushing elements onto the stack and then popping them off."
      }
    },
    "codeSnippets": {
      "C++": {
        "constructor": "template <typename T>\nStack<T>::Stack(/* args */)\n{\n    this->size = 0;\n    this->head = nullptr;\n}",
        "destructor": "template <typename T>\nStack<T>::~Stack()\n{\n    while (!this->isEmpty())\n        T item = this->pop();\n}",
        "push": "template <typename T>\nvoid Stack<T>::push(T value)\n{\n    Node<T> *new_head = new Node<T>(value);\n    new_head->prev = this->head;\n    this->head = new_head;\n    this->size++;\n}",
        "pop": "template <typename T>\nT Stack<T>::pop()\n{\n    if (this->isEmpty()) throw std::out_of_range(\"Stack is empty\");\n    T value = this->head->value;\n    Node<T> *old_head = this->head;\n    this->head = old_head->prev;\n    delete old_head;\n    this->size--;\n    return value;\n}",
        "isEmpty": "template <typename T>\nbool Stack<T>::isEmpty()\n{\n    return this->head == nullptr;\n}",
        "main": "#include <iostream>\n#include <string>\n#include <vector>\n#include 'Stack.h'\n\nusing namespace std;\n\nint main(){\n    Stack<string> stack = Stack<string>();\n    vector<string> sampleVec = {\"This\",\"is\",\"a\",\"sample\",\"vector\"};\n    cout << stack.isEmpty() << endl;\n    for (int i = 0; i < sampleVec.size(); i++)\n{\n        cout << \"Push: \" << sampleVec[i] << endl;\n        stack.push(sampleVec[i]);\n}"
      },
      "Python": {
        "constructor": "class Stack:\n    def __init__(self):\n        self.items = []",
        "destructor": "def __del__(self):\n        print(\"Stack is being deleted\")",
        "push": "def push(self, item):\n    self.items.append(item)",
        "pop": "def pop(self):\n    if not self.isEmpty():\n        return self.items.pop()\n    raise IndexError('pop from empty stack')",
        "isEmpty": "def isEmpty(self):\n    return len(self.items) == 0",
        "main": "if __name__ == '__main__':\n    stack = Stack()\n    stack.push(1)\n    stack.push(2)\n    print(stack.pop())\n    print(stack.isEmpty())"
      }
    },
    "comments": []
  },
  {
    "id": 2,
    "title": "Linked Lists Explained: From Basics to Advanced",
    "description": "Explore linked lists, a versatile data structure that allows for dynamic memory allocation, with clear examples and comparisons to arrays in C++ and Python.",
    "category": "Data Structures",
    "publishDate": "2024-09-26",
    "programmingLanguages": ["C++", "Python"],
    "details": {
      "C++": "In C++, linked lists can be implemented using pointers and structs or classes. A linked list consists of nodes where each node contains data and a pointer to the next node. Common operations include insertion, deletion, and traversal."
    },
    "descriptions": {
      "C++": {
        "constructor": "This is the constructor for the LinkedList class. It initializes an empty linked list with the head pointer set to `nullptr`.",
        "destructor": "This is the destructor for the LinkedList class. It deallocates all the nodes in the list to free memory, ensuring no memory leaks occur.",
        "insert": "The insert method adds a new node with the specified value to the end of the list. It traverses the list and links the new node to the last node.",
        "deleteNode": "The deleteNode method removes the node with the given value. It adjusts the links between nodes to maintain the integrity of the list, deleting the node when found.",
        "print": "The print method traverses the linked list and prints each node’s data in sequence, separated by arrows ('->') to represent the links between them.",
        "main": "This is the main function, which demonstrates how to create a linked list, insert nodes, delete nodes, and print the list."
      },
      "Python": {
        "constructor": "This is the constructor for the LinkedList class in Python. It initializes an empty linked list with the head pointer set to None.",
        "destructor": "This is the destructor for the LinkedList class in Python. Although Python has automatic garbage collection, this method can be implemented to explicitly free memory if needed.",
        "insert": "The insert method adds a new node with the specified value at the end of the linked list. It checks if the head is None and updates it accordingly, or traverses to the last node to link the new node.",
        "delete": "The delete method removes the first node that contains the specified value. It handles cases where the node to delete is the head or a node further down the list.",
        "print": "The printList method traverses the linked list and prints each node’s data in sequence, separated by arrows ('->'). It provides a visual representation of the links between nodes.",
        "main": "This is the main function, which demonstrates how to create a linked list in Python, insert nodes, delete nodes, and print the list."
      }
    },
    "codeSnippets": {
      "C++": {
        "constructor": "// Template struct for Node\ntemplate <typename T>\nstruct Node\n{\n    T data;     // Data stored in the node\n    Node<T> *prev; // Pointer to the next node\n\n    // Constructor to initialize the node\n    Node<T>(T value) : data(value), prev(nullptr) {}\n};\n\ntemplate <typename T>\nLinkedList<T>::LinkedList()\n{\n    this->head = nullptr;\n}\n\n// Initializes the head to nullptr, indicating an empty list.",
        "destructor": "template <typename T>\nLinkedList<T>::~LinkedList()\n{\n    Node<T> *temp;\n    while (head) {\n        temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\n// Frees memory by deleting all nodes in the list.",
        "insert": "template <typename T>\nvoid LinkedList<T>::insert(T val)\n{\n    Node<T> *newNode = new Node<T>(val);\n    if (!head) {\n        head = newNode;\n    } else {\n        Node<T> *temp = head;\n        while (temp->next) {\n            temp = temp->next;\n        }\n        temp->next = newNode;\n    }\n}\n\n// Inserts a new node with the value `val` at the end of the list.",
        "delete": "template <typename T>\nbool LinkedList<T>::deleteNode(T val)\n{\n    if (!head) return false;\n    if (head->data == val) {\n        Node<T> *temp = head;\n        head = head->next;\n        delete temp;\n        return true;\n    }\n    Node<T> *temp = head;\n    while (temp->next) {\n        if (temp->next->data == val) {\n            Node<T> *nodeToDelete = temp->next;\n            temp->next = temp->next->next;\n            delete nodeToDelete;\n            return true;\n        }\n        temp = temp->next;\n    }\n    return false;\n}\n\n// Deletes the node with the given value `val`.",
        "print": "template <typename T>\nvoid LinkedList<T>::print()\n{\n    Node<T> *temp = head;\n    while (temp) {\n        std::cout << temp->data;\n        if (temp->next != nullptr)\n            std::cout << \" -> \";\n        temp = temp->next;\n    }\n    std::cout << std::endl;\n}\n\n// Prints the linked list by traversing from head to the last node.",
        "main": "#include <iostream>\n#include \"LinkedList.h\"\n\nint main()\n{\n    LinkedList<int> linkedList;\n    linkedList.insert(1);\n    linkedList.insert(2);\n    linkedList.insert(3);\n    linkedList.print();\n\n    linkedList.deleteNode(1);\n    linkedList.print();\n    linkedList.deleteNode(2);\n    linkedList.print();\n    linkedList.deleteNode(3);\n    linkedList.print();\n    return 0;\n}\n\n// Demonstrates inserting, deleting, and printing nodes in the linked list."
      },
      "Python": {
        "constructor": "class Node:\n    def __init__(self, value) -> None:\n        self.data: int = value  # Store the data value\n        self.next: 'Node' = None  # Initialize the next pointer to None\n\nclass LinkedList:\n    def __init__(self) -> None:\n        self.head: Node = None  # Initialize the head to None, indicating an empty list.",
        "destructor": "def __del__(self):\n    \"\"\"Destructor to clean up nodes when the list is no longer needed.\"\"\"\n    current = self.head\n    while current:\n        next_node = current.next\n        del current  # Explicitly deleting node\n        current = next_node",
        "insert": "def insert(self, val) -> None:\n        \"\"\"Inserts a new node with the specified value at the end of the list.\"\"\"\n        newNode = Node(val)\n\n        if self.head is None:\n            self.head = newNode\n        else:\n            temp = self.head\n            while temp.next:\n                temp = temp.next\n            temp.next = newNode\n\n        # Inserts a new node with the value `val` at the end of the list.",
        "delete": "def delete(self, val) -> bool:\n        \"\"\"Deletes the first node with the specified value from the list.\n        Returns True if the node was deleted, False if not found.\n        \"\"\"\n        if self.head is None:  # If the list is empty\n            return False\n\n        # Deleting the head node\n        if self.head.data == val:\n            self.head = self.head.next  # Move the head to the next node\n            return True\n\n        # Traverse the list to find the node to delete\n        current = self.head\n        while current.next:  # Ensure we're not accessing null pointers\n            if current.next.data == val:  # Node to delete found\n                current.next = current.next.next  # Bypass the node to delete it\n                return True\n            current = current.next  # Move to the next node\n\n        return False  # Value not found in the list\n\n        # Deletes the first node with the specified value `val`.",
        "print": "def printList(self):\n        temp = self.head\n        while temp:\n            print(temp.data,end=\"\")\n            if temp.next:\n                print(\" -> \",end=\"\")\n            temp = temp.next\n        print()\n\n        # Prints the linked list by traversing from head to the last node.",
        "main": "def main():\n    linked_list = LinkedList()\n    linked_list.insert(1)\n    linked_list.insert(2)\n    linked_list.insert(3)\n    linked_list.printList()  # Output: 1 -> 2 -> 3\n\n    linked_list.delete(2)\n    linked_list.printList()  # Output: 1 -> 3\n    linked_list.delete(1)\n    linked_list.printList()  # Output: 3\n    linked_list.delete(3)\n    linked_list.printList()  # Output: \n\nif __name__ == '__main__':\n    main()\n\n        # Demonstrates inserting, deleting, and printing nodes in the linked list."
      }
    },
    "comments": []
  },
  {
    "id": 3,
    "title": "Hash Table Explained: Efficient Data Lookup",
    "description": "Dive into the details of hash tables, a fundamental data structure that provides fast lookups, insertions, and deletions using hash functions, implemented in both C++ and Python.",
    "category": "Data Structures",
    "publishDate": "2024-10-01",
    "programmingLanguages": ["C++", "Python"],
    "details": {
      "C++": "In C++, a hash table can be implemented using arrays or vectors, with hash functions to map values to indices. Collision resolution techniques such as chaining or open addressing are commonly used. This implementation uses chaining with vectors to handle collisions.",
      "Python": "In Python, hash tables are abstracted by dictionaries. They are dynamic and provide average O(1) complexity for lookups, insertions, and deletions using built-in hash functions."
    },
    "descriptions": {
      "C++": {
        "constructor": "This is the constructor for the HashTable class. It initializes a hash table with a specified size and sets up the table as a vector of vectors, allowing for collision handling with separate chaining.",
        "destructor": "This is the destructor for the HashTable class. It ensures that all dynamically allocated memory is properly freed when the hash table is no longer in use. The C++ vector automatically handles memory deallocation, so no explicit memory cleanup is needed.",
        "insert": "The insert method adds a value to the hash table by computing the hash value (using modulo division by the size of the table) and storing it in the appropriate bucket. If the bucket is full due to collisions, insertion fails.",
        "lookup": "The lookup method checks whether a given value exists in the hash table by computing its hash and searching through the list of elements in the corresponding bucket.",
        "main": "This main function demonstrates how to initialize the hash table, insert values, and check for the presence of values using the lookup function."
      },
      "Python": {
        "constructor": "This is the constructor for a hash table in Python. In Python, hash tables are implemented using dictionaries, so the constructor simply initializes an empty dictionary.",
        "insert": "The insert method adds a key-value pair to the dictionary, where the key is hashed automatically by Python's internal hash function. No manual collision handling is needed.",
        "lookup": "The lookup method checks for the existence of a key in the dictionary using Python's built-in `in` keyword. If the key exists, it retrieves the associated value.",
        "main": "This main function shows how to create a hash table using Python's dictionary, insert key-value pairs, and perform lookups efficiently."
      }
    },
    "codeSnippets": {
      "C++": {
        "constructor": "// Constructor to initialize the hash table\nHashTable::HashTable(int s)\n{\n    this->size = s;\n    // Initialize the table with 'size' buckets and each bucket allowing 5 collisions, initialized with -1 (empty)\n    this->table = std::vector<std::vector<int>>(size, std::vector<int>(5, -1));\n}",
        "destructor": "",
        "insert": "",
        "lookup": "",
        "delete": "",
        "main": ""
      },
      "Python": {
        "constructor": "",
        "destructor": "",
        "insert": "",
        "lookup": "",
        "delete": "",
        "main": ""
      }
    },
    "comments": []
  }
]
